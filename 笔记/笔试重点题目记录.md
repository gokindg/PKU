### 笔试题目整理

****

#### 0402/笔试

##### 选择

1.若定义二叉树中根结点的层数为零，树的高度等于其结点的最大层数加一。则当某二叉树的前序序列和后序序列正好相反，则该二叉树一定是（ B ）的二叉树。

<u>解析：前序根左右；后续左右根。因此每个节点只有一个根。</u>
A： 空或只有一个结点 B：高度等于其节点数
C： 任一结点无左孩子 D： 任一结点无右孩子

2.假设线性表中每个元素有两个数据项 key1 和 key2，现对线性表按以下规则进行排序：先根据数据项 key1 的值进行非递减排序；在 key1 值相同的情况下，再根据数据项 key2 的值进行非递减排序。
满足这种要求的排序方法是（ D ）。

<u>解析：冒泡排序是稳定排序，直接选择排序是不稳定排序。</u>
A: 先按key1 值进行冒泡排序，再按 key2 值进行直接选择排序
B: 先按key2 值进行冒泡排序，再按 key1 值进行直接选择排序
C: 先按key1 值进行直接选择排序，再按 key2 值进行冒泡排序
D: 先按key2 值进行直接选择排序，再按 key1 值进行冒泡排序

3.有一个散列表如下图所示，其散列函数为 h(key)=key mod 13，该散列表使用再散列函数
H2(Key)=Key MOD 3 解决碰撞，问从表中检索出关键码 38 需进行几次比较（ B ）。

<u>解析：先用第一个函数，得到两个值，然后再模3向后移两个，所以是两次。第一次和25冲突，找第二次时不冲突。</u>

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 26   | 38   |      |      | 17   |      |      | 33   |      | 48   |      |      | 25   |

A： 1 B：2 C: 3 D： 4

4.在一棵度为 3 的树中，度为 3 的节点个数为 2，度为 2 的节点个数为 1，则度为 0 的节点个数为（ C ）。

<u>解析：度是指一个节点的子节点数量，一棵树的度是指最大的节点的度。</u>
A： 4 B：5 C： 6 D： 7

5.在映射抽象数据类型（ADT Map）的不同实现方法中，适合对动态查找表进行高效率查找的组织结构是（ C ）。

<u>解析：动态查找：表格不固定，可能会有数的变化。有序表不适合动态；堆排序只适合查找最大最小值，并且不维护有序性，并且不支持键值查找；快速排序不是组织结构而是算法。</u>
A： 有序表 B：堆排序 C： 二叉排序树 D： 快速排序

6.下列叙述中正确的是（ A ）。

A：一个逻辑结构可以有多种类型的存储结构，且不同类型的存储结构会直接影响到数据处理的效率

B：散列是一种基于索引的逻辑结构 <u>解析：不是基于索引是用hash函数计算的。</u>

C：基于顺序表实现的逻辑结构属于线性结构  <u>解析：堆是基于顺序表实现的，但堆是一种完全二叉树结构而不是顺序结构。</u>

D：数据结构设计影响算法效率，逻辑结构起到了决定作用 <u>解析：逻辑结构和存储结构同样重要。</u>

##### 判断

7.（ Y ）考虑一个长度为 n 的顺序表中各个位置插入新元素的概率是相同的，则顺序表的插入算法平均时间复杂度为 O(n) 。<u>若在开头插入则所有元素索引都要调整。</u>

8.（ N ）希尔排序算法的每一趟都要调用一次或多次直接插入排序算法，所以其效率比直接插入排序算法差。<u>希尔排序：相当于直接插入排序的优化。直接插入排序：O(N^2)</u>

9.（ N ）由于碰撞的发生，基于散列表的检索仍然需要进行关键码对比，并且关键码的比较次数仅取决于选择的散列函数与处理碰撞的方法两个因素。<u>和加入的元素也有关系。</u>

10.（ N ）若有一个叶子结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点。<u>考虑一个只有左节点的二叉树，则前序遍历和中序遍历相反。</u>

11.（ Y ）若某非空且无重复元素二叉树的先序序列和后序序列正好相同，则该二叉树只有一个根结点。<u>先序根在前后序根在后。</u>

12.（ Y ）按照前序、中序、后序方式周游一棵二叉树，分别得到不同的结点周游序列，然而三种不同的周游序列中，叶子结点都将以相同的顺序出现。<u>都是左在右前。</u>

13.（ N ）构建一个含 N 个结点的（二叉）最小值堆，时间效率最优情况下的时间复杂度大 O 表示为 O (N Log N)。<u>时间效率最优是O(N）建堆的最优时间复杂度是O(N)</u>

##### 填空

1. 线性表的顺序存储与链式存储是两种常见存储形式；当表元素有序排序进行二分检索时，应采用 _ _ _ _ 存储形式。**（顺序）** <u>（链式存储只能从头检索。）</u>
2. 如果只想得到1000 个元素的序列中最小的前 5个元素，在冒泡排序、快速排序(不稳定)、堆排序<u>(O(KLogN))</u>和归并排序<u>(O(NlogN))</u>中，哪种算法最快？**（堆排序）**
3. 设环形队列的容量为 20（单元编号从 0 到19），现经过一系列的入队和出队运算后，队头变量（第一个元素的位置）front=18，队尾变量（待插入元素的位置）rear=11，在这种情况下，环形队列中有 _ _ _ _ 个元素。**（13）**<u>(取出了18-11之间的元素再加上11本身。)</u>
4. 一棵含有101个结点的二叉树中有36个叶子结点，度为 2 的结点个数是 _ _ _ _ 和度为１的结点个数是 _ _ _ _ 。**（35，30）** <u>（度不为0则代表不是叶子节点，列方程1+2x+y=101；x+y=101-36）</u>
5. 如果一个图节点多而边少（稀疏图），适宜采用邻接矩阵 <u>（密集图）</u> 和邻接表 <u>（稀疏图）</u>中的 _ _ _ _ 方式进行存储。
6. 定义完全二叉树的根结点所在层为第一层。如果一个完全二叉树的第六层有 23 个叶结点，则它的总结点数可能为？（请填写所有 3 个可能的结点数，写对 1 个得 1 分，2 个得 1.5 分，写 错 1 个不得分）。**（54，80，81）**

<u>#可以是第六层是满的 但是叶节点只有23个 还有9个结点是非叶结点。这样第七层要么是17个节点要么是18个。(1+2+4+8+16+32) + 17 或 18 = 80，或 81</u>

##### 备注

散列表：元素存储位置和其关键字之间有某种直接关系。（Hash search）例如字典。

p=H（key）p:散列地址；H(散列函数)

散列表：有限连续，存储按散列函数计算得到的散列地址。

冲突：H(key1)=H(key2);key1,key2为同义词。

避免冲突

1.数字分析法：分析关键字每一位上各种数字分布情况。

2.平方取中法

3.折叠法

4.除留余数法

处理冲突

1.开放地址法：线性探测、二次探测、伪随机探测法

2.链地址法：得到同义词链表。



****

#### 0507/笔试

##### 选择

1.下列叙述中正确的是（ D ）。
A：散列是一种基于索引的逻辑结构 <u>基于哈希函数。</u>
B：基于顺序表实现的逻辑结构属于线性结构 <u>顺序表也可以实现完全二叉树（堆），不一定线性。</u>
C：数据结构设计影响算法效率，逻辑结构起到了决定作用 <u>（数据结构）存储结构同等重要</u>
D：一个逻辑结构可以有多种类型的存储结构，且不同类型的存储结构会直接影响到数据处理的效率 

2.以下典型排序算法中，内存开销最大的是（ C ） 。
A：冒泡排序    B：快速排序
C：归并排序 <u>额外空间O(N)</u>    D：堆排序

3.排序算法依赖于对元素序列的多趟比较/移动操作（即执行多轮循环），第一趟结束后，任一元素都无法确定其最终排序位置的算法是（ D ）。

A：选择排序 <u>每次确定一个元素位置</u>     B：快速排序 <u>每次确定一个元素位置</u>    C: 冒泡排序 <u>每次确定一个元素位置</u>   D：插入排序

4.考察以下基于单链表的操作，相较于顺序表实现，带来更高时间复杂度的操作是（ D ）。<u>链表查找没有顺序表快</u>
A：合并两个有序线性表，并保持合成后的线性表依然有序 
B：交换第一个元素与第二个元素的值 
C：查找某一元素值是否在线性表中出现 
D：输出第 i 个（0<=i<n，n 为元素个数）元素

5.今有一非连通无向图，共有 36 条边，该图至少有（ C ）个顶点。<u>无向连通图：N=n(n-1)//2</u>
A：8  B：9 C：10  D：11

##### 判断

1. （ Y ）按照前序、中序、后序方式周游一棵二叉树，分别得到不同的结点周游序列，然而三种不同的周游序列中，叶子结点都将以相同的顺序出现。
2. （ N ）构建一个含 N 个结点的（二叉）最小值堆，时间效率最优情况下的时间复杂度大 O 表示为 O (N Log N)。 <u>应该是O(N)</u>
3. （ N ）对任意一个连通的无向图，如果存在一个环，且这个环中的一条边的权值不小于该环中任意一个其它的边的权值，那么这条边一定不会是该无向图的最小生成树中的边。 <u>把不小于改为大于。</u>
4. （ Y ）通过树的周游可以求得树的高度，若采取深度优先遍历方式设计求解树高度问题的算法，算法空间复杂度大 O 表示为 O（树的高度）。 <u>递归用到栈空间，递归次数和高度相关。</u>
5. （ Y ）树可以等价转化二叉树，树的<u>先序遍历序列与其相应的二叉树的前序遍历序</u>列相同。 
6. （ Y ）如果一个连通无向图 G 中所有边的权值均不同，则 G 具有唯一的最小生成树。
7. （ Y ）求解最小生成树问题的 Prim 算法是一种贪心算法。
8. （ Y ）Dijkstra 算法的局限性是无法正确求解带有负权值边的图的最短路径。

##### 填空

1.定义二叉树中一个结点的度数为其子结点的个数。现有一棵结点总数为 101 的二叉树，其中度数为 1 的结点数有 30 个，则度数为 0 结点有 _ _ _ _ 个。**36** <u>x+y=101-30；1+2x+30=101</u>

2.包含 n 个顶点无向图的邻接表存储结构中，所有顶点的边表中最多有 _ _ _ _ 个结点。具有 n 个顶点的有向图，顶点入度和出度之和最大值不超过 _ _ _ _ 。**n(n-1), 2(n-1)** <u>出度入度各（n-1）；所有顶点的边表中最多包含的节点个数是边的两倍。</u>

****

#### 0514/笔试

##### 选择

1.双向链表中的每个结点有两个引用域，prev 和 next，分别引用当前结点的前驱与后继，设 p 引用链表中的一个结点，q 引用一待插入结点，现要求在 p 前插入 q，则正确的插入操作为（ D  ）。

A：p.prev=q; q.next=p; p.prev.next=q; q.prev=p.prev;
B：q.prev=p.prev; p.prev.next=q; q.next=p; p.prev=q.next;
C：q.next=p; p.next=q; p.prev.next=q; q.next=p;
**D：p.prev.next=q; q.next=p; q.prev=p.prev; p.prev=q.**

<u>#假设链表是 ![$A <-> B <-> C$](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC)*A*<−>*B*<−>*C*，要在 B 前插入 Q，那么会得到 ![$A <-> Q <-> B <-> C $](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC)*A*<−>*Q*<−>*B*<−>*C*的链表。这是在结点 B 前插入 Q 结点的步骤：</u>

1. <u>`p.prev.next = q;` 这一步是把 p 的前一个结点的 next 指针指向 q。在例子中，是把 A 的 next 指针指向 Q。</u>
2. <u>`q.next = p;` 这一步是把 q 的 next 指针指向 p。在例子中，是把 Q 的 next 指针指向 B。</u>
3. <u>`q.prev = p.prev;` 这一步是把 q 的 prev 指针指向 p 的前一个结点。在例子中，是把 Q 的 prev 指针指向 A。</u>
4. <u>`p.prev = q;` 这一步是把 p 的 prev 指针指向 q。在例子中，是把 B 的 prev 指针指向 Q。</u>

2.数据结构有三个基本要素:逻辑结构、存储结构以及基于结构定义的行为(运算)。下列概念中( B )属于存储结构。
A:线性表	**B:链表**	C:字符串	D:二叉树

<u>#在这些选项中，有些描述的是数据的逻辑结构，而有些是存储结构。逻辑结构指的是数据对象中数据元素之间的相互关系，而存储结构是指数据结构在计算机中的表示（也就是内存中的存储形式）。</u>

<u>A: **线性表** - 这是一种逻辑结构，它描述元素按线性顺序排列的规则。</u>
<u>B: 链表 - 这是一种存储结构，它是线性表的链式存储方式，通过节点的相互链接来实现。</u>

<u>正确答案是 B: 链表，因为它指的是数据的物理存储方式，即内存中的链式存储结构。</u>

3.假设需要对存储开销 1GB (GigaBytes) 的数据进行排序，但主存储器（RAM）当前可用的存储空间只有 100MB (MegaBytes)。针对这种情况，（ B ）排序算法是最适合的。
A：堆排序	**B：归并排序**	C：快速排序	D：插入排序

<u>#对于这种情况，最适合的排序算法是归并排序（B）。</u>

<u>归并排序是一种外部排序算法，它的主要思想是将数据分成较小的块，然后逐步合并这些块以获得有序的结果。由于主存储器的可用空间有限，归并排序非常适合这种情况，因为它可以在有限的主存中进行部分排序，并将排序好的部分写入外部存储（磁盘）中。然后再将不同部分进行合并，直到得到完全排序的结果。</u>

<u>堆排序（A）通常需要对整个数据集进行排序，因此不适合主存储器有限的情况。</u>

<u>快速排序（C）通常是一种原地排序算法，它需要频繁地交换数据，这可能导致频繁的磁盘访问，不适合主存储器有限的情况。</u>

<u>插入排序（D）的时间复杂度较低，但它需要频繁地移动数据，这可能导致频繁的磁盘访问，也不适合主存储器有限的情况。</u>

4.以下（ C ）分组中的两个排序算法的最坏情况下时间复杂度的大 O 表示相同。
A：快速排序和堆排序 B：归并排序和插入排序 C：**快速排序和选择排序** D：堆排序和冒泡排序

<u>#选项C：快速排序和选择排序中的两个排序算法的最坏情况下时间复杂度的大 O 表示相同。</u>

<u>快速排序和选择排序都属于不同的排序算法，但它们的最坏情况下的时间复杂度都是O(n^2)。</u>

<u>快速排序的最坏情况下时间复杂度发生在每次选择的基准元素都划分出了一个很小的子序列，使得递归的深度达到了n，导致时间复杂度为O(n^2)。</u>

<u>选择排序的最坏情况下时间复杂度发生在每次选择最小（或最大）元素时，需要遍历未排序部分的所有元素，导致时间复杂度为O(n^2)。</u>

##### 判断

5.（ N ）分治算法通常将原问题分解为几个规模较小但类似于原问题的子问题，并要求算法实现写成某种递归形式，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

<u>#递归的求解子问题，最后子问题足够小可以直接求解，形式不一定是递归。</u>

<u>#分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。</u>

6.（ Y ）考察某个具体问题是否适合应用动态规划算法，必须判定它是否具有最优子结构性质。

<u>#如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有**最优子结构(Optimal Substructure)**。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来。因此，一个问题必须拥有最优子结构，才能使用动态规划去解决。例如数塔问题中，每一个位置的 dp 值都可以由它的两个子问题推导得到。</u>
<u>至此，重叠子问题和最优子结构的内容已介绍完毕。需要指出，**一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决**。</u>

##### 填空

1.对长度为 3 的顺序表进行查找，若查找第一个元素的概率为 1/2，查找第二个元素的概率为 1/4，查找第三个元素的概率为 1/8，则执行任意查找需要比较元素的平均个数为 _ _ _ _ 。

<u>#$1*(1/2) + 2*(1/4) + 3*(1/8) + 3*(1/8) = 1.75$, 还有1/8的失败查询概率。</u>

****

#### 0521/笔试

##### 绪论

1.在数据结构中，从逻辑上可以把数据结构分成（ C  ）。

A．动态结构和静态结构   B．紧凑结构和非紧凑结构

C．线性结构和非线性结构  D．内部结构和外部结构

2.通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着( B )。

A．数据具有同一特点

B．不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致

C．每个数据元素都一样

D．数据元素所包含的数据项的个数要相等

3.以下与数据的存储结构无关的术语是（ C ）。
A．顺序队列    B. 链表    C. 有序表     D. 链栈

##### 线性表

1.在n个结点的顺序表中，算法的时间复杂度是O(1)的操作是（ A ）

A．访问第i个结点（1≤i≤n）和求第i个结点的直接前驱（2≤i≤n） 

B．在第i个结点后插入一个新结点（1≤i≤n）

C．删除第i个结点（1≤i≤n）

D．将n个结点从小到大排序

2.链接存储的存储结构所占存储空间（ A ）。

A．分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针

B．只有一部分，存放结点值

C．只有一部分，存储表示结点间关系的指针

D．分两部分，一部分存放结点值，另一部分存放结点所占单元数

3.线性表若采用链式存储结构时，要求内存中可用存储单元的地址（ D ）。

A．必须是连续的    B．部分地址必须是连续的

C．一定是不连续的   D．连续或不连续都可以

4.线性表Ｌ在（ B  ）情况下适用于使用链式结构实现。

A．需经常修改Ｌ中的结点值   Ｂ．需不断对Ｌ进行删除插入 

C．Ｌ中含有大量的结点     Ｄ．Ｌ中结点结构复杂

5.若指定有n个元素的向量，则建立一个有序单链表的时间复杂性的量级是（ C ）。
A．O(1)      B．O(n)       C．O(n^2)      D．$O(nlog_2n)$

<u>#建立一个有序单链表的时间复杂度是$O(n^2)$。这是因为在单链表中插入元素需要遍历链表找到正确的位置，而每次插入的时间复杂度是O(n)，如果需要插入n个元素，那么总的时间复杂度就是O(n^2)。</u>

##### 栈和队列

1.数组Ｑ［ｎ］用来表示一个循环队列，ｆ为当前队列头元素的前一位置，ｒ为队尾元素的位置，假定队列中元素的个数小于ｎ，计算队列中元素个数的公式为（ D ）。

A．r-f       B．(n+f-r)%n    C．n+r-f      D．（n+r-f)%n

2.栈在 （ D ）中有所应用。

A．递归调用    B．函数调用   C．表达式求值    D．前三个选项都有

3.用链接方式存储的队列，在进行删除运算时（ D ）。

A. 仅修改头指针            B. 仅修改尾指针

C. 头、尾指针都要修改        D. 头、尾指针可能都要修改

<u>#特别是在删除队列中最后一个元素时，也需要更新尾指针。</u>

4.循环队列存储在数组A[0..m]中，则入队时的操作为（ D ）。

A. rear=rear+1            B. rear=(rear+1)%(m-1)

 C. rear=(rear+1)%m          D. rear=(rear+1)%(m+1)

5.最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（ B ）。

 A. (rear+1)%n == front          B. rear == front                             

C．rear+1 == front           D. (rear-l)%n == front

##### 串和数组

1.串是一种特殊的线性表，其特殊性体现在（ B ）。

 A．可以顺序存储        B．数据元素是一个字符   

C．可以链式存储        D．数据元素可以是多个字符

2.若对n阶对称矩阵A以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1..(n(n+1))/2]中，则在B中确定aij（i<j）的位置k的关系为（ B ）。

A．i*(i-1)/2+j    B．j * (j-1)/2+i   C．i * (i+1)/2+j   D．j * (j+1)/2+i

3.A[N，N]是对称矩阵，将下面三角（包括对角线）以行序存储到一维数组T[N(N+1)/2]中，则对任一上三角元素a\[i][j]对应T[k]的下标k是（ B ）。

A．i(i-1)/2+j    B．j(j-1)/2+i    C．i(j-i)/2+1    D．j(i-1)/2+1

4.设二维数组A[1.. m，1.. n]（即m行n列）按行存储在数组B[1.. m*n]中，则二维数组元素A[i,j]在一维数组B中的下标为（ A ）。

A．(i-1) * n+j    B．(i-1) * n+j-1   C．i * (j-1)     D．j * m+i-1

##### 树和二叉树

1.对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左右孩子中，其左孩子的编号小于其右孩子的编号，可采用（ C ）遍历实现编号。

A．先序     B. 中序      C. 后序    D. 从根开始按层次遍历

2.若二叉树采用二叉链表存储结构，要交换其所有分支结点左、右子树的位置，利用（ C ）遍历方法最合适。

A．前序     B．中序       C．后序   D．按层次

<u>#A、C、D应该都对。C是类似于递归自底向上，D是自顶向下。这种题目与实现有关，出成选择题不合适。</u>

3.在下列存储形式中，（ D ）不是树的存储形式？

A．双亲表示法  B．孩子链表表示法  C．孩子兄弟表示法  D．顺序存储表示法

4.设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有（ C ）个。

A． n-1      B．n           C． n+1      D． n+2

##### 图

1.n个顶点的连通图用邻接距阵表示时，该距阵至少有（ B  ）个非零元素。

A．n        B．2(n-1)     C．n/2      D．n^2 

2.若从无向图的任意一个顶点出发进行一次深度优先搜索可以访问图中所有的顶点，则该图一定是（ B ）图。

A．非连通     B．连通      C．强连通    D．有向

3.下面（ A ）算法适合构造一个稠密图G的最小生成树。

A． Prim    B．Kruskal<u>（稀疏图）</u>  C．Floyd   D．Dijkstra

4.深度优先遍历类似于二叉树的（ A ）。

A．先序遍历    B．中序遍历     C．后序遍历   D．层次遍历

5.广度优先遍历类似于二叉树的（ D ）。

A．先序遍历    B．中序遍历     C．后序遍历    D．层次遍历

6.图的BFS生成树的树高比DFS生成树的树高（ C  ）。

A．小       B．相等       C．小或相等    D．大或相等

7.下面（ B ）方法可以判断出一个有向图是否有环。

A．深度优先遍历    B．拓扑排序    C．求最短路径   D．求关键路径

##### 查找

1.对n个元素的表做顺序查找时，若查找每个元素的概率相同，则平均查找长度为（ C ）。

A．(n-1)/2    B． n/2    C．(n+1)/2    D．n 

<u>#对于顺序查找，如果每个元素被查找的概率相同，并且元素在表中均匀分布，那么平均查找长度（Average Search Length，ASL）可以通过元素在表中的位置的期望值来计算。</u>

<u>考虑在顺序查找中，每个元素被查找时，它可能在表中的位置分别为 1 到 n。因此，元素在表中的位置的期望值为：</u>

<u>期望位置 = $\frac{1 + 2 + 3 + \cdots + n}{n} = \frac{n(n+1)}{2n} = \frac{n+1}{2} $</u>

<u>因此，平均查找长度为 $ \frac{n+1}{2} $。所以答案是选项 C．</u>

2.适用于折半查找的表的存储方式及元素排列要求为（ D ）。

 A．链接方式存储，元素无序       B．链接方式存储，元素有序

C．顺序方式存储，元素无序      D．顺序方式存储，元素有序

3.当在一个有序的顺序表上查找一个数据时，既可用折半查找，也可用顺序查找，但前者比后者的查找速度（ C ）。           

A．必定快              B．不一定  

C．在大部分情况下要快        D．取决于表递增还是递减

4.折半搜索与二叉排序树的时间性能（ C  ）。

 A．相同               B．完全不同    

C．有时不相同            D．数量级都是$O(log_2n)$

<u>#对于二叉搜索树（BST），如果树是平衡的，那么在平均情况下，查找、插入和删除的时间复杂度也是 𝑂(log⁡𝑛)。但是，如果树不平衡，例如退化为链表，那么时间复杂度可能会变为 𝑂(𝑛)。</u>

5.在平衡二叉树中插入一个结点后造成了不平衡，设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平衡因子为1，则应作（ C ）型调整以使其平衡。

A．LL      B．LR     C．RL      D．RR

6.下列关于m阶B-树的说法错误的是（ D ）。  

A．根结点至多有m棵子树   

B．所有叶子都在同一层次上

C．非叶结点至少有m/2 (m为偶数)或m/2+1（m为奇数）棵子树  

D．根结点中的数据是有序的

7.下面关于哈希查找的说法，不正确的是（ A ）。       

 A．采用链地址法处理冲突时，查找一个元素的时间是相同的

 B．采用链地址法处理冲突时，若插入规定总是在链首，则插入任一个元素的时间是相同的

 C．用链地址法处理冲突，不会引起二次聚集现象

 D．用链地址法处理冲突，适合表长不确定的情况

<u>二次探测法的公式为： [ h(key, i) = (H(key) + i^2) % 14 ] 其中，( H(key) ) 是哈希函数计算出的初始位置， ( i ) 是探测的次数。</u>

##### 排序

1.对n个不同的关键字由小到大进行冒泡排序，在下列（ B ）情况下比较的次数最多。

A．从小到大排列好的         B．从大到小排列好的  

 C．元素无序             D．元素基本有序

2.对n个不同的排序码进行冒泡排序，在元素无序的情况下比较的次数最多为（ D  ）。

A．n+1      B．n        C．n-1        D．n(n-1)/2

3.快速排序在下列（ C ）情况下最易发挥其长处。

A．被排序的数据中含有多个相同排序码  

B．被排序的数据已基本有序  

C．被排序的数据完全无序     

D．被排序的数据中的最大值和最小值相差悬殊

4.对n个关键字作快速排序，在最坏情况下，算法的时间复杂度是（ B ）。

A．O(n)      B．O(n^2)       C．$O(nlog_2n)$     D．O(n^3) 

5.堆是一种（ B ）排序。

A．插入     B．选择     C．交换    D．归并

<u>#在堆排序中，我们不断地从堆顶取出元素，并且对剩余的元素进行调整，使得堆的性质得到维护。这种不断地选择最大（或最小）元素的过程称为选择排序。因此，堆排序是一种选择排序算法。</u>

6.堆的形状是一棵（ C ）。

A．二叉排序树      B．满二叉树     C．完全二叉树   D．平衡二叉树

7.数据表中有10000个元素，如果仅要求求出其中最大的10个元素，则采用( D )算法最节省时间。

A．冒泡排序     B．快速排序     C．简单选择排序  D．堆排序





